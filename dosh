#!/bin/bash
#
# Copyright (c) 2017-2018 GaÃ«l PORTAY <gael.portay@savoirfairelinux.com>
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the MIT License.
#

# Called as program loader (shebang #!/usr/bin/dosh)
__="$_"
if [ "$__" != "/bin/bash" ] && [ "$__" = "$1" ]; then
	exec <"$1"
	shift
	set -- -s "$@"
	exec "$0" "$@"
elif [ "$__" != "/bin/bash" ] && [ "$__" = "$2" ]; then
	args="$1"
	shift
	exec <"$1"
	shift
	# shellcheck disable=SC2086
	set -- $args -s "$@"
	exec "$0" "$@"
fi

set -e
set -o pipefail

VERSION="1.2"

usage() {
	cat <<EOF
Usage: ${0##*/} [OPTIONS] [COMMAND] [ARG...]

Run a shell as user in a container and bind mount cwd.

POSIX Shell related options:
      -c                        Read commands from command-line.
      -i                        Set interactive.
      -s                        Read commands from standard-input.

Docker related options:
      -F or --dockerfile FILE   Path to the Dockerfile to use.
      -C or --directory DIR     Change to directory before doing anything else.
            --root              Run as root.
            --home              Bind mount home directory.
            --sh                Set /bin/sh as default shell.
                                Equivalent to set DOSHELL=/bin/sh,
                                           or set --shell /bin/sh.
                                This option is deprecated; use --shell instead.
            --shell SHELL       Set shell interpretor.
            --build             Build image.
            --rmi               Remove image.
            --detach            Detach container.
            --exec CONTAINER    Execute in container.
            --tag               Print docker tag and exit.
      -N or --no-do             Do nothing; echo docker commands.

Miscellaneous options:
      -v or --verbose           Turn on verbose mode.
      -V or --version           Print version.
      -h or --help              Print usage.

Environment variables:
      DOCKER                    The docker executable.

      DOSHELL                   The full pathname to the shell to run in docker
                                image.
                                Equivalent to --shell SHELL

      DOSHLVL                   Incremented by one each time an instance of dosh
                                is started.

      DOSH_DOCKERFILE           The filename of the Dockerfile to use.
                                Equivalent to --dockerfile FILE

      DOSH_DOCKER_RUN_EXTRA_OPTS
                                Set additionnal parameters to docker run
                                command.

      DOSH_DOCKER_EXEC_EXTRA_OPTS
                                Set additionnal parameters to docker exec
                                command.

      DOSH_DOCKER_BUILD_EXTRA_OPTS
                                Set additionnal parameters to docker build
                                command.

      DOSH_DOCKER_RMI_EXTRA_OPTS
                                Set additionnal parameters to docker rmi
                                command.
EOF
}

get_tag() {
	echo "dosh-$(realpath "$1" | sha256sum - | cut -d' ' -f1)"
}

docker_build() {
	if [ -n "$DOSH_NOBUILD" ]; then
		return
	fi

	lineno=0
	while read -r -a words; do
		if [[ ${words[0]} =~ ADD|COPY|ENTRYPOINT ]]; then
			echo "Warning: Ignoring line #$lineno: \`${words[*]}'"
		fi
		lineno=$((lineno+1))
	done <"$1" >&2
	unset lineno

	# shellcheck disable=SC2086
	cat "$1" - <<EOF | \
	sed -e '/^\(ADD\|COPY\|ENTRYPOINT\)/d' | \
	$do $DOCKER build $buildopts --tag "$2" $DOSH_DOCKER_BUILD_EXTRA_OPTS -

USER root
RUN groupadd --non-unique --gid ${GROUPS[0]} $USER \
 || addgroup -g ${GROUPS[0]} $USER
RUN useradd  --non-unique --gid ${GROUPS[0]} --uid $UID --create-home --home-dir $HOME --shell /bin/sh $USER \
 || adduser  -G $USER -u $UID -h $HOME -s /bin/sh -D $USER
EOF
}

docker_rmi() {
	# shellcheck disable=SC2086
	$do $DOCKER rmi $DOSH_DOCKER_RMI_EXTRA_OPTS "$1"
}

opt_i=false
opt_s=false
opt_c=false
DOSH_DOCKERFILE="${DOSH_DOCKERFILE:-Dockerfile}"
directory="."
root=false
home=false
build=false
rmi=false
detach=false
exec=false
buildopts="--quiet"
verbose=false
DOSHELL="${DOSHELL:-/bin/sh}"
DOCKER="${DOCKER:-docker}"
while [ "$#" -ne 0 ]; do
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
		usage
		exit 0
	elif [ "$1" = "-V" ] || [ "$1" = "--version" ]; then
		echo "$VERSION"
		exit
	elif [ "$1" = "-F" ] || [ "$1" = "--dockerfile" ]; then
		shift
		DOSH_DOCKERFILE="$1"
	elif [ "$1" = "-C" ] || [ "$1" = "--directory" ]; then
		shift
		directory="$1"
	elif [ "$1" = "--root" ]; then
		root=true
	elif [ "$1" = "--home" ]; then
		home=true
	elif [ "$1" = "--sh" ]; then
		DOSHELL="/bin/sh"
	elif [ "$1" = "--shell" ]; then
		shift
		DOSHELL="$1"
	elif [ "$1" = "--build" ]; then
		build=true
	elif [ "$1" = "--rmi" ]; then
		rmi=true
	elif [ "$1" = "--detach" ]; then
		detach=true
	elif [ "$1" = "--exec" ]; then
		shift
		container="$1"
		exec=true
	elif [ "$1" = "--tag" ]; then
		get_tag "$directory/$DOSH_DOCKERFILE"
		exit
	elif [ "$1" = "-N" ] || [ "$1" = "--no-do" ]; then
		# shellcheck disable=SC2209
		do=echo
	elif [ "$1" = "-v" ] || [ "$1" = "--verbose" ]; then
		verbose="true"
		buildopts=
	elif [ "$1" = "-c" ]; then
		shift
		opt_c=true
		break
	elif [ "$1" = "-i" ]; then
		opt_i=true
	elif [ "$1" = "-s" ]; then
		shift
		opt_s=true
		break
	elif [ "$1" = "--" ]; then
		shift
		break
	else
		break
	fi
	shift
done

# Change directory
cd "$directory"

if [ -e ".doshrc" ]; then
	. .doshrc
fi

if $rmi; then
	# Remove image if exist
	tag="$(get_tag "$DOSH_DOCKERFILE")"
	docker_rmi "$tag" >&2
	exit
fi

# Run in a new container
if ! $exec; then
	# Rebuild or automatically build image if it does not exist
	tag="$(get_tag "$DOSH_DOCKERFILE")"
	imageid="$($DOCKER images -q "$tag")"
	if $build || [ -z "$imageid" ]; then
		[ -n "$imageid" ] || buildopts=
		docker_build "$DOSH_DOCKERFILE" "$tag" >&2
	fi

	# Detach container
	if $detach; then
		opts="--detach"
	# Remove the container at exit
	else
		opts="--rm"
	fi

	# Bind mount home
	if $home; then
		opts+=" --volume $HOME:/home/$USER"
	# Bind mount current working directory
	else
		opts+=" --volume $PWD:$PWD"
	fi
fi

# Set current user privileges
if ! $root; then
	opts+=" --user $UID:${GROUPS[0]}"
fi

# Set interactive
if $opt_i || $opt_s || [ "$#" -eq 0 ]; then
	opts+=" --interactive"

	# Allocate a pseudo-TTY if stdin/stderr are TTY
	if [ -t 0 ] && [ -t 2 ]; then
		opts+=" --tty"
	fi
fi

# Read command from stdin
if $opt_s; then
	set -- "$DOSHELL" -c "cd $PWD && $DOSHELL -s $(eval echo "${@// /\\\\ }")"
# Run command from arguments
elif $opt_c; then
	command="$1"
	shift
	set -- "$DOSHELL" -c "cd $PWD && $DOSHELL -c '$command' $*"
# No command or invalid
else
	set -- "$DOSHELL" -c "cd $PWD && $DOSHELL $*"
fi

# Execute in existing container
# shellcheck disable=SC2086
if $exec; then
	exec $do $DOCKER exec $opts $DOSH_DOCKER_EXEC_EXTRA_OPTS "$container" "$@"
# Run in a new container
else
	opts+=" --env DOSHLVL=$((DOSHLVL+1))"
	if $verbose; then
		echo "$tag"
	fi >&2
	exec $do $DOCKER run $opts $DOSH_DOCKER_RUN_EXTRA_OPTS "$tag" "$@"
fi
